/*
Go ↔︎ SQL, tool for mapping between Go structs and SQL records. NOT AN ORM, and
should be used instead of an ORM. Expressly designed to let you WRITE PLAIN SQL.

Example usage:

	type External struct {
		Id    string `db:"id"`
		Name  string `db:"name"`
	}

	type Internal struct {
		Id   string `db:"id"`
		Name string `db:"name"`
	}

	// Step 1: generate query.

	var result []External

	query := fmt.Sprintf(`select %v from (
		select
			external.*,
			internal as internal
		from
			external
			cross join internal
	) as _
	`, gos.Cols(result))

	// Resulting query (formatted here for readability):
	// select
	// 	"id",
	// 	"name",
	// 	("internal")."id"   as "internal.id",
	// 	("internal")."name" as "internal.name"
	// from (
	// 	...
	// ) as _

	// Step 2: use query.

	err := gos.Query(ctx, conn, &result, query, nil)

	fmt.Printf("%#v\n", result)

Struct rules

When decoding a row into a struct, Gos observes the following rules.

1. Columns are matched to public struct fields whose `db` tag exactly matches
the column name. Private fields or fields without `db` are completely
ignored. Example:

	type Result struct {
		A string `db:"a"`
		B string // ignored: no `db` tag
		c string // ignored: private
	}

2. Fields of embedded structs are treated as part of the enclosing struct. For
example, these two definitions are completely equivalent:

	type Result struct {
		A string `db:"a"`
		Embedded
	}
	type Embedded struct {
		B string `db:"b"`
	}

	type Result struct {
		A string `db:"a"`
		B string `db:"b"`
	}

3. Fields of nested non-embedded structs are matched with columns whose aliases
look like `"outer_field.inner_field.innermost_field"` with arbitrary nesting.
Example:

	-- Query:
	select
		'one' as "outer_val",
		'two' as "inner.inner_val";

	// Go types:
	type Outer struct {
		OuterVal string `db:"outer_val"`
		Inner    Inner  `db:"inner"`
	}
	type Inner struct {
		InnerVal string `db:"inner_val"`
	}

4. If every column from a nested struct is null or missing, the entire nested
struct is considered null. If the field is not nilable (struct, not pointer
to struct), this will produce an error. Otherwise, the field is left nil and
not allocated. This convention is extremely useful for outer joins, where
nested records are often null. Example:

	-- Query:
	select
		'one' as "outer_val",
		null  as "inner.inner_val";

	// Go types:
	type Outer struct {
		OuterVal string `db:"outer_val"`
		Inner    *Inner `db:"inner"`
	}
	type Inner struct {
		InnerVal string `db:"inner_val"`
	}

	// Output:
	Outer{OuterVal: "one", Inner: nil}

Differences from sqlx

Gos is very similar to https://github.com/jmoiron/sqlx. Key differences:

	* Supports null records in outer joins, as nested struct pointers
	* Selects fields explicitly without relying on `select *`
	* Helps to generate `insert` and `update` queries from structs
	* Much simpler API, does not wrap `database/sql`
	* Explicit field-column mapping, no hidden renaming
	* No special utilities for named parameters
	* Depends only on the standard library (the `go.mod` dependencies are test-only)

Notes on array support

Gos doesn't specially support SQL arrays. Generally speaking, SQL arrays are
usable only for primitive types such as numbers or strings. Some databases, such
as Postgres, have their own implementations of multi-dimensional arrays, which
are non-standard and have so many quirks and limitations that it's more
practical to just use JSON. Arrays of primitives are already supported in
adapters such as "github.com/lib/pq", which are orthogonal to Gos and used in
combination with it.
*/
package gos

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strings"
	"time"
)

/*
Main API of this library. Scans columns into the destination, which may be one
of:

	* single scalar
	* slice of scalars
	* single struct
	* slice of structs

If the destination is a non-slice, there must be exactly one row. Less or more
will result in an error. If the destination is a struct, this will decode
columns into struct fields, following the rules outlined above in the package
overview.

The `select` part of the query must be generated by calling `Cols(dest)`. See
the example below.
*/
func Query(ctx context.Context, conn tQueryer, dest interface{}, query string, args []interface{}) error {
	rval := reflect.ValueOf(dest)
	if !isNonNilPointer(rval) {
		return ErrInvalidDest.because(fmt.Errorf(`destination must be a non-nil pointer, received %#v`, dest))
	}

	rtype := derefRtype(rval.Type())

	if rtype.Kind() == reflect.Slice {
		elemRtype := derefRtype(rtype.Elem())
		if elemRtype.Kind() == reflect.Struct && !isScannableRtype(elemRtype) {
			return queryStructs(ctx, conn, rval, query, args)
		}
		return queryScalars(ctx, conn, rval, query, args)
	}

	if rtype.Kind() == reflect.Struct && !isScannableRtype(rtype) {
		return queryStruct(ctx, conn, rval, query, args)
	}
	return queryScalar(ctx, conn, dest, query, args)
}

/*
Takes a struct or struct slice and generates a string for inclusion into
`select`. Allowed inputs: struct, struct pointer, slice of structs, slice of
struct pointers, pointer to slice. Any other input causes a panic.

Should be used in conjunction with `Query()`. See the examples below.
*/
func Cols(input interface{}) string {
	rtype := derefRtype(reflect.TypeOf(input))
	if rtype.Kind() == reflect.Slice {
		rtype = derefRtype(rtype.Elem())
	}
	idents := structTypeSqlIdents(rtype)
	return sqlIdent{idents: idents}.selectString()
}

/*
Use these blank errors to detect error type:

	if errors.Is(err, gos.ErrNoRows) {
		// Handle specific error.
	}

Note that errors returned by Gos can't be compared via `==` because they may
include additional details about the circumstances. Use `errors.Is`.
*/
var (
	ErrNoRows       Err = Err{Code: ErrCodeNoRows, Cause: sql.ErrNoRows}
	ErrMultipleRows Err = Err{Code: ErrCodeMultipleRows, Cause: errors.New(`expected one row, got multiple`)}
	ErrInvalidDest  Err = Err{Code: ErrCodeInvalidDest, Cause: errors.New(`invalid destination type`)}
	ErrNoColDest    Err = Err{Code: ErrCodeNoColDest, Cause: errors.New(`column has no matching destination`)}
	ErrRedundantCol Err = Err{Code: ErrCodeRedundantCol, Cause: errors.New(`redundant column occurrence`)}
	ErrNull         Err = Err{Code: ErrCodeNull, Cause: errors.New(`null column for non-nilable field`)}
	ErrScan         Err = Err{Code: ErrCodeScan, Cause: errors.New(`error while scanning into field`)}
)

// Describes a Gos error.
type Err struct {
	Code  ErrCode
	While string
	Cause error
}

// Implement `error`.
func (self Err) Error() string {
	if self == (Err{}) {
		return ""
	}
	msg := `SQL error`
	if self.Code != ErrCodeUnknown {
		msg += fmt.Sprintf(` %s`, self.Code)
	}
	if self.While != "" {
		msg += fmt.Sprintf(` while %v`, self.While)
	}
	if self.Cause != nil {
		msg += `: ` + self.Cause.Error()
	}
	return msg
}

// Implement a hidden interface in "errors".
func (self Err) Is(other error) bool {
	if self.Cause != nil && errors.Is(self.Cause, other) {
		return true
	}
	err, ok := other.(Err)
	return ok && err.Code == self.Code
}

// Implement a hidden interface in "errors".
func (self Err) Unwrap() error {
	return self.Cause
}

func (self Err) while(while string) Err {
	self.While = while
	return self
}

func (self Err) because(cause error) Err {
	self.Cause = cause
	return self
}

/*
Describes the specific error type. You probably shouldn't use this directly;
instead, use `errors.Is` with the various `Err` variables.
*/
type ErrCode byte

const (
	ErrCodeUnknown ErrCode = iota
	ErrCodeNoRows
	ErrCodeMultipleRows
	ErrCodeInvalidDest
	ErrCodeNoColDest
	ErrCodeRedundantCol
	ErrCodeNull
	ErrCodeScan
)

// Implement `fmt.Stringer`.
func (self ErrCode) String() string {
	switch self {
	case ErrCodeNoRows:
		return "ErrNoRows"
	case ErrCodeMultipleRows:
		return "ErrMultipleRows"
	case ErrCodeInvalidDest:
		return "ErrInvalidDest"
	case ErrCodeNoColDest:
		return "ErrNoColDest"
	case ErrCodeRedundantCol:
		return "ErrRedundantCol"
	case ErrCodeNull:
		return "ErrNull"
	case ErrCodeScan:
		return "ErrScan"
	default:
		return ""
	}
}

/* Internal */

const expectedStructDepth = 8

// Satisfied by `*sql.DB`, `*sql.Tx`, etc.
type tQueryer interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
}

type tDestSpec struct {
	colNames  []string
	colRtypes map[string]reflect.Type
	typeSpec  tTypeSpec
}

type tTypeSpec struct {
	rtype      reflect.Type
	fieldSpecs []tFieldSpec
}

type tFieldSpec struct {
	parentFieldSpec *tFieldSpec
	typeSpec        tTypeSpec
	fieldIndex      int
	fieldPath       []int // Relative to root struct.
	colName         string
	uniqColAlias    string
	colIndex        int // Must be initialized to -1.
	sfield          reflect.StructField
}

type tDecodeState struct {
	colPtrs []interface{}
}

/*
The destination must be a pointer to a non-scannable struct.
*/
func queryStruct(ctx context.Context, conn tQueryer, rval reflect.Value, query string, args []interface{}) error {
	rows, err := conn.QueryContext(ctx, query, args...)
	if err != nil {
		return Err{While: `querying rows`, Cause: err}
	}
	defer rows.Close()

	spec, err := prepareDestSpec(rows, rval.Type())
	if err != nil {
		return err
	}

	state, err := prepareDecodeState(rows, spec)
	if err != nil {
		return err
	}

	if !rows.Next() {
		return ErrNoRows.while(`preparing row`)
	}

	err = rows.Scan(state.colPtrs...)
	if err != nil {
		return Err{While: `scanning row`, Cause: err}
	}

	err = traverseDecode(rval, spec, state, &spec.typeSpec, nil)
	if err != nil {
		return err
	}

	if rows.Next() {
		return ErrMultipleRows.while(`verifying row count`)
	}

	return nil
}

/*
The destination must be a pointer to a slice of non-scannable structs or
pointers to those structs.
*/
func queryStructs(ctx context.Context, conn tQueryer, rval reflect.Value, query string, args []interface{}) error {
	elemRtype := derefRtype(rval.Type()).Elem()

	rows, err := conn.QueryContext(ctx, query, args...)
	if err != nil {
		return Err{While: `querying rows`, Cause: err}
	}
	defer rows.Close()

	spec, err := prepareDestSpec(rows, reflect.PtrTo(elemRtype))
	if err != nil {
		return err
	}

	sliceRval := derefAllocRval(rval)
	// When the slice is nil, this leaves it as nil.
	sliceRval.SetLen(0)

	for rows.Next() {
		state, err := prepareDecodeState(rows, spec)
		if err != nil {
			return err
		}

		err = rows.Scan(state.colPtrs...)
		if err != nil {
			return Err{While: `scanning row`, Cause: err}
		}

		elemPtrRval := reflect.New(elemRtype)

		err = traverseDecode(elemPtrRval, spec, state, &spec.typeSpec, nil)
		if err != nil {
			return err
		}

		sliceRval.Set(reflect.Append(sliceRval, elemPtrRval.Elem()))
	}

	return nil
}

func queryScalar(ctx context.Context, conn tQueryer, dest interface{}, query string, args []interface{}) error {
	rows, err := conn.QueryContext(ctx, query, args...)
	if err != nil {
		return Err{While: `querying rows`, Cause: err}
	}
	defer rows.Close()

	if !rows.Next() {
		return ErrNoRows.while(`preparing row`)
	}

	err = rows.Scan(dest)
	if err != nil {
		return Err{While: `scanning row`, Cause: err}
	}

	if rows.Next() {
		return ErrMultipleRows.while(`verifying row count`)
	}

	return nil
}

/*
The destination must be a pointer to a slice of scannables or primitives.
*/
func queryScalars(ctx context.Context, conn tQueryer, rval reflect.Value, query string, args []interface{}) error {
	elemRtype := derefRtype(rval.Type()).Elem()

	rows, err := conn.QueryContext(ctx, query, args...)
	if err != nil {
		return Err{While: `querying rows`, Cause: err}
	}
	defer rows.Close()

	sliceRval := derefAllocRval(rval)
	// When the slice is nil, this leaves it as nil.
	sliceRval.SetLen(0)

	for rows.Next() {
		elemPtrRval := reflect.New(elemRtype)

		err = rows.Scan(elemPtrRval.Interface())
		if err != nil {
			return Err{While: `scanning row`, Cause: err}
		}

		sliceRval.Set(reflect.Append(sliceRval, elemPtrRval.Elem()))
	}

	return nil
}

func prepareDestSpec(rows *sql.Rows, rtype reflect.Type) (*tDestSpec, error) {
	if rtype == nil || rtype.Kind() != reflect.Ptr || derefRtype(rtype).Kind() != reflect.Struct {
		return nil, Err{
			Code:  ErrCodeInvalidDest,
			While: `preparing destination spec`,
			Cause: fmt.Errorf(`expected destination type to be a struct pointer, got %q`, rtype),
		}
	}

	colNames, err := rows.Columns()
	if err != nil {
		return nil, Err{While: `getting columns`, Cause: err}
	}

	spec := &tDestSpec{
		typeSpec:  tTypeSpec{rtype: rtype},
		colNames:  colNames,
		colRtypes: map[string]reflect.Type{},
	}

	colPath := make([]string, 0, expectedStructDepth)
	fieldPath := make([]int, 0, expectedStructDepth)
	err = traverseMakeSpec(spec, &spec.typeSpec, nil, colPath, fieldPath)
	if err != nil {
		return nil, err
	}

	for _, colName := range colNames {
		if spec.colRtypes[colName] == nil {
			return nil, Err{
				Code:  ErrCodeNoColDest,
				While: `preparing destination spec`,
				Cause: fmt.Errorf(`column %q doesn't have a matching destination in type %q`, colName, rtype),
			}
		}
	}

	return spec, nil
}

func prepareDecodeState(rows *sql.Rows, spec *tDestSpec) (*tDecodeState, error) {
	colPtrs := make([]interface{}, 0, len(spec.colNames))
	for _, colName := range spec.colNames {
		if spec.colRtypes[colName] == nil {
			return nil, Err{
				Code:  ErrCodeNoColDest,
				While: `preparing decode state`,
				Cause: fmt.Errorf(`column %q doesn't have a matching destination in type %q`,
					colName, spec.typeSpec.rtype),
			}
		}
		colPtrs = append(colPtrs, reflect.New(reflect.PtrTo(spec.colRtypes[colName])).Interface())
	}
	return &tDecodeState{colPtrs: colPtrs}, nil
}

func traverseMakeSpec(spec *tDestSpec, typeSpec *tTypeSpec, parentFieldSpec *tFieldSpec, colPath []string, fieldPath []int) error {
	rtypeElem := derefRtype(typeSpec.rtype)
	typeSpec.fieldSpecs = make([]tFieldSpec, rtypeElem.NumField())

	for i := 0; i < rtypeElem.NumField(); i++ {
		sfield := rtypeElem.Field(i)
		fieldRtype := derefRtype(sfield.Type)
		fieldPath := append(fieldPath, i)

		fieldSpec := &typeSpec.fieldSpecs[i]
		*fieldSpec = tFieldSpec{
			parentFieldSpec: parentFieldSpec,
			typeSpec:        tTypeSpec{rtype: sfield.Type},
			fieldIndex:      i,
			fieldPath:       copyIntSlice(fieldPath),
			colIndex:        -1,
			sfield:          sfield,
		}

		if !isStructFieldPublic(sfield) {
			continue
		}

		if sfield.Anonymous && fieldRtype.Kind() == reflect.Struct {
			err := traverseMakeSpec(spec, &fieldSpec.typeSpec, fieldSpec, colPath, fieldPath)
			if err != nil {
				return err
			}
			continue
		}

		fieldSpec.colName = structFieldColumnName(sfield)
		if fieldSpec.colName == "" {
			continue
		}

		colPath := append(colPath, fieldSpec.colName)
		fieldSpec.uniqColAlias = strings.Join(colPath, ".")
		fieldSpec.colIndex = stringIndex(spec.colNames, fieldSpec.uniqColAlias)

		if spec.colRtypes[fieldSpec.uniqColAlias] != nil {
			return Err{
				Code:  ErrCodeRedundantCol,
				While: `preparing destination spec`,
				Cause: fmt.Errorf(`redundant occurrence of column %q`, fieldSpec.uniqColAlias),
			}
		}
		spec.colRtypes[fieldSpec.uniqColAlias] = sfield.Type

		if fieldRtype.Kind() == reflect.Struct && !isScannableRtype(fieldRtype) {
			err := traverseMakeSpec(spec, &fieldSpec.typeSpec, fieldSpec, colPath, fieldPath)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func traverseDecode(rootRval reflect.Value, spec *tDestSpec, state *tDecodeState, typeSpec *tTypeSpec, fieldSpec *tFieldSpec) error {
	everyColValueIsNil := true

	for i := range typeSpec.fieldSpecs {
		fieldSpec := &typeSpec.fieldSpecs[i]
		sfield := fieldSpec.sfield
		fieldRtype := derefRtype(sfield.Type)

		if !isStructFieldPublic(sfield) {
			continue
		}

		if sfield.Anonymous && fieldRtype.Kind() == reflect.Struct {
			err := traverseDecode(rootRval, spec, state, &fieldSpec.typeSpec, fieldSpec)
			if err != nil {
				return err
			}
			continue
		}

		if fieldSpec.colName == "" {
			continue
		}

		if fieldRtype.Kind() == reflect.Struct && !isScannableRtype(fieldRtype) {
			err := traverseDecode(rootRval, spec, state, &fieldSpec.typeSpec, fieldSpec)
			if err != nil {
				return err
			}
			continue
		}

		if !(fieldSpec.colIndex >= 0) {
			continue
		}

		colRval := reflect.ValueOf(state.colPtrs[fieldSpec.colIndex]).Elem()
		if !colRval.IsNil() {
			everyColValueIsNil = false
		}
	}

	isNested := fieldSpec != nil
	if everyColValueIsNil && isNested && isNilableOrHasNilableNonRootAncestor(fieldSpec) {
		return nil
	}

	for _, fieldSpec := range typeSpec.fieldSpecs {
		if !(fieldSpec.colIndex >= 0) {
			continue
		}

		sfield := fieldSpec.sfield
		colRval := reflect.ValueOf(state.colPtrs[fieldSpec.colIndex]).Elem()

		if colRval.IsNil() {
			if isNilableRkind(sfield.Type.Kind()) {
				continue
			}

			fieldRval := derefAllocStructRvalAt(rootRval, fieldSpec.fieldPath)
			scanner, ok := fieldRval.Addr().Interface().(sql.Scanner)
			if ok {
				err := scanner.Scan(nil)
				if err != nil {
					return Err{Code: ErrCodeScan, While: `scanning into field`, Cause: err}
				}
				continue
			}

			return Err{
				Code:  ErrCodeNull,
				While: `decoding into struct`,
				Cause: fmt.Errorf(`type %q at field %q of struct %q is not nilable, but corresponding column %q was null`,
					sfield.Type, sfield.Name, typeSpec.rtype, fieldSpec.uniqColAlias),
			}
		}

		fieldRval := derefAllocStructRvalAt(rootRval, fieldSpec.fieldPath)
		fieldRval.Set(colRval.Elem())
	}

	return nil
}

func stringIndex(strs []string, str string) int {
	for i := range strs {
		if strs[i] == str {
			return i
		}
	}
	return -1
}

var timeRtype = reflect.TypeOf(time.Time{})
var sqlScannerRtype = reflect.TypeOf((*sql.Scanner)(nil)).Elem()

func isScannableRtype(rtype reflect.Type) bool {
	return rtype != nil &&
		(rtype == timeRtype || reflect.PtrTo(rtype).Implements(sqlScannerRtype))
}

func isNonNilPointer(rval reflect.Value) bool {
	return rval.IsValid() && rval.Kind() == reflect.Ptr && !rval.IsNil()
}

func copyIntSlice(vals []int) []int {
	out := make([]int, len(vals), len(vals))
	copy(out, vals)
	return out
}

func isNilableOrHasNilableNonRootAncestor(fieldSpec *tFieldSpec) bool {
	for fieldSpec != nil {
		if isNilableRkind(fieldSpec.typeSpec.rtype.Kind()) {
			return true
		}
		fieldSpec = fieldSpec.parentFieldSpec
	}
	return false
}

func structTypeSqlIdents(structRtype reflect.Type) []sqlIdent {
	var idents []sqlIdent

	traverseStructFields(structRtype, func(sfield reflect.StructField) {
		colName := structFieldColumnName(sfield)
		if colName == "" {
			return
		}

		fieldRtype := derefRtype(sfield.Type)
		if fieldRtype.Kind() == reflect.Struct && !isScannableRtype(fieldRtype) {
			idents = append(idents, sqlIdent{
				name:   colName,
				idents: structTypeSqlIdents(fieldRtype),
			})
			return
		}

		idents = append(idents, sqlIdent{name: colName})
		return
	})

	return idents
}

type sqlIdent struct {
	name   string
	idents []sqlIdent
}

func (self sqlIdent) selectString() string {
	return bytesToString(self.appendSelect(nil, nil))
}

func (self sqlIdent) appendSelect(buf []byte, path []string) []byte {
	if len(self.idents) == 0 {
		if self.name == "" {
			return buf
		}
		if len(buf) > 0 {
			buf = append(buf, ", "...)
		}
		if len(path) == 0 {
			buf = appendIdentAlias(buf, path, self.name)
		} else {
			buf = appendIdentPath(buf, path, self.name)
			buf = append(buf, " as "...)
			buf = appendIdentAlias(buf, path, self.name)
		}
		return buf
	}

	if self.name != "" {
		path = append(path, self.name)
	}
	for _, ident := range self.idents {
		buf = ident.appendSelect(buf, path)
	}
	return buf
}

func appendIdentPath(buf []byte, path []string, ident string) []byte {
	for i, name := range path {
		if i == 0 {
			buf = append(buf, '(', '"')
			buf = append(buf, name...)
			buf = append(buf, '"', ')')
		} else {
			buf = append(buf, '"')
			buf = append(buf, name...)
			buf = append(buf, '"')
		}
		buf = append(buf, '.')
	}
	buf = append(buf, '"')
	buf = append(buf, ident...)
	buf = append(buf, '"')
	return buf
}

func appendIdentAlias(buf []byte, path []string, ident string) []byte {
	buf = append(buf, '"')
	for _, name := range path {
		buf = append(buf, name...)
		buf = append(buf, '.')
	}
	buf = append(buf, ident...)
	buf = append(buf, '"')
	return buf
}

func bytesToString(bytes []byte) string { return string(bytes) }

func stringToBytes(input string) []byte { return []byte(input) }

func traverseStructFields(rtype reflect.Type, fun func(sfield reflect.StructField)) {
	rtype = derefRtype(rtype)
	if rtype == nil || rtype.Kind() != reflect.Struct {
		panic(fmt.Errorf("expected a struct type, got a %q", rtype))
	}

	for i := 0; i < rtype.NumField(); i++ {
		sfield := rtype.Field(i)
		if !isStructFieldPublic(sfield) {
			continue
		}

		/**
		If this is an embedded struct, traverse its fields as if they're in the
		parent struct.
		*/
		if sfield.Anonymous && derefRtype(sfield.Type).Kind() == reflect.Struct {
			traverseStructFields(sfield.Type, fun)
			continue
		}

		fun(sfield)
	}
}

func derefRtype(rtype reflect.Type) reflect.Type {
	for rtype != nil && rtype.Kind() == reflect.Ptr {
		rtype = rtype.Elem()
	}
	return rtype
}

/*
Derefs the provided value until it's no longer a pointer, allocating as
necessary. Returns a non-pointer value. The input value must be settable or a
non-nil pointer, otherwise this causes a panic.
*/
func derefAllocRval(rval reflect.Value) reflect.Value {
	for rval.Kind() == reflect.Ptr {
		if rval.IsNil() {
			rval.Set(reflect.New(rval.Type().Elem()))
		}
		rval = rval.Elem()
	}
	return rval
}

/*
Finds or allocates an rval at the given struct field path, returning the
resulting reflect value. If the starting value is settable, the resulting value
should also be settable. Ditto if the starting value is a non-nil pointer and
the path is not empty.

Assumes that every type on the path, starting with the root, is a struct type or
an arbitrarily nested struct pointer type. Panics if the assumption doesn't
hold.
*/
func derefAllocStructRvalAt(rval reflect.Value, path []int) reflect.Value {
	for _, i := range path {
		rval = derefAllocRval(rval)
		rval = rval.Field(i)
	}
	return rval
}

func isStructFieldPublic(sfield reflect.StructField) bool {
	return sfield.PkgPath == ""
}

func structFieldColumnName(sfield reflect.StructField) string {
	tag := sfield.Tag.Get("db")
	if tag == "-" {
		return ""
	}
	return tag
}

func isNilableRkind(kind reflect.Kind) bool {
	switch kind {
	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
		return true
	default:
		return false
	}
}
